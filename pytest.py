from collections import deque

b, p, c, n = (int(i) for i in input().split(','))
queue = [int(input()) for _ in range(p+c)]

buffer = deque()

class Person:
	def __init__(self, id, max_iter, max_buffer):
		self.id = abs(id)
		self.iter = 0
		self.max_iter = max_iter
		self.waiting = False
		self.done = False
		self.max_buffer = max_buffer

class Producer(Person):
	def go(self, buffer):
		if self.iter < self.max_iter:
			if len(buffer) < self.max_buffer:
				self.iter += 1
				buffer.append(self.id)
				return f"Producer {self.id} is producing item number {self.iter}"
			else:
				return f"Producer {self.id} is waiting"
		else:
			self.done = True

class Consumer(Person):
	def go(self, buffer):
		if self.iter < self.max_iter:
			if buffer:
				self.iter += 1
				i = buffer.popleft()
				return f"Consumer {self.id} is consuming item generated by Producer {i}"
			else:
				return f"Consumer {self.id} is waiting"
		else:
			self.done = True

queue = deque(Producer(i, n, b) if i > 0 else Consumer(-i, n, b) for i in queue)
wait = {Producer: deque(), Consumer: deque()}

while queue:
	p = queue.popleft()
	str = p.go(buffer)
	if not str:
		continue
	print("\n", str, "\n", end="")
	if "wait" in str:
		wait[type(p)].append(p)
	elif "item" in str:
		if type(p) is Producer:
			if wait[Consumer]:
				queue.append(wait[Consumer].popleft())
		else:
			if wait[Producer]:
				queue.append(wait[Producer].popleft())
		queue.append(p)
